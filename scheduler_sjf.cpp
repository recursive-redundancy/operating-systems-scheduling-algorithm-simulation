//Scheduler Simulation (Shortest Job First)
// by Daniel Morgan

// Program generates 50 unique processes with random properties
// and runs a Shortest Job First scheduler using these processes.
//
// Program implements and builds upon a process generator created for a homework assignment
// and adds logic for the SJF scheduler.
// The Scheduler_SJF class works in conjunction with a contained ProcessGenerator object (which contains the list of random Process objects)
// and a list (vector) of Processor objects with which to execute jobs
//
// Each step within the scheduler (switching to and from processes) is output to standard output, and this
// output can be redirected to be saved to a text file, for example. This is the way in which our team 
// has saved output data for analysis
#include <iostream>
#include <iomanip>
#include <math.h>
#include <random>
#include <stdlib.h>
#include <vector>

const int CONTEXT_PENALTY = 10; // Penalty (in cycles) for a context switch

// A single process
class Process
{
private:
	unsigned int arrivalTime; // time process arrived (in cycles)
	unsigned int waitTime; // wait time (calculated during scheduling algorithm)
	int cycleLength; // totatl lifetime of process (in cycles)
	unsigned int memFootprint; // memory footprint (in KB)
	unsigned int pid; // unique process id
public:
	Process(unsigned int pid, unsigned int arrivalTime, int cycleLength, unsigned int memFootprint)
	{
		this->pid = pid;
		this->arrivalTime = arrivalTime;
		this->cycleLength = cycleLength;
		this->memFootprint = memFootprint;
		this->waitTime = 0;
	}
	unsigned int getArrivalTime()
	{
		return this->arrivalTime;
	}
	int getCycleLength()
	{
		return this->cycleLength;
	}
	unsigned int getMemFootprint()
	{
		return this->memFootprint;
	}
	unsigned int getPID()
	{
		return this->pid;
	}
	unsigned int getWaitTime()
	{
		return this->waitTime;
	}
	// Decrements cycle length by 1 cycle (called by scheduler when simulating one cycle)
	void decrementCycle()
	{
		this->cycleLength--;
	}
	// Set the cycle length
	// Arg1 is cycle length to set
	void setCycleLength(int cycleLength)
	{
		this->cycleLength = cycleLength;
	}
	// Sets the process's wait time (called by scheduler)
	// Arg1 is time to wait (in cycles)
	void setWaitTime(unsigned int waitTime)
	{
		this->waitTime = waitTime;
	}
};	

// Encapsulates a generated list of processes
// & methods to generate & manage these processes
class ProcessGenerator
{
friend class Scheduler_SJF; // Allow scheduler to access process list
private:
	// The following rules govern the random creation of each single process
	// -Rules for cycle count
	static const int Cycles_Min = 1000;
	static const int Cycles_Mean = 6000;
	static const int Cycles_Max = 11000;
	// -Rules for memory footprint (in KB)
	static const int Mem_Min = 1;
	static const int Mem_Mean = 20;
	static const int Mem_Max = 100;
	// End Rules
	std::vector <Process> processes; // List of generated processes
	std::default_random_engine randGen; // engine for random # generation
public:
	// Constructor initializes processes list to empty
	ProcessGenerator()
	{
		this->clear();
		randGen.seed(std::time(0)); // seed random generator by calendar time to randomize well
	}
	// Clears the list of processes
	void clear()
	{
		this->processes.clear();
	}
	// Batch generates multiple processes
	// arg1 is the # of processes to generate
	void generate_batch(int numProcesses)
	{
		this->processes.clear();
		for (int i = 0; i < numProcesses; i++)
		{
			this->generate_process();
		}
	}
	// Generates a single process with random properties
	// Process ID is generated by taking the current size of the process list (before new insertion, pid is zero-indexed so the size of vector will give proper id)
	// Cycle length & memory footprint are randomly generated to be distributed as normally as possible about the mean (gaussian distribution)
	void generate_process()
	{
		unsigned int arrivalTime;

		if (processes.size() < 1)
		{
			arrivalTime = 0; // first process arrives at zero
		}
		else
		{
			arrivalTime = processes[processes.size() - 1].getArrivalTime() + 50; // subsequent processes arrive 50 cycles after previous
		}
		Process p(this->processes.size(), arrivalTime, random_cycle(), random_mem()); // Create new process
		
		processes.push_back(p); // Add to list of processes
	}
	// Generates and returns a random cycle length
	// Following the bounds of Cycles_Min & Cycles_Max
	// And distributed normally about Cycles_Mean
	int random_cycle()
	{
		// Half the possible range of values to orient about a standard bell curve
		float halfRange = round((Cycles_Max - Cycles_Min) / 2);
		// For standard deviation, cut the normalized range in half and divide by 3 (since 99.7% of values lie within 3 s.d.)
		std::normal_distribution<double> dist(0, (Cycles_Max - Cycles_Min) / 3);

		float num; // randomly generated #
		bool isValid;
		do // generate a random normally distributed # until it falls within necessary range
		{
			isValid = true;
			num = dist(this->randGen);
			num = round(num);
			if (num < -halfRange || num > halfRange)
			{
				isValid = false;
			}
		} while (!isValid);
		num = num + Cycles_Min + (Cycles_Mean - Cycles_Min);
		int finalNum = (int)num;

		return finalNum;
	}
	// Generates and returns a random memory footprint size
	// Following the bounds of Cycles_Min & Cycles_Max
	// And distributed normally about Cycles_Mean
	int random_mem()
	{
		std::normal_distribution<double> dist(Mem_Mean, (Mem_Max - Mem_Min) / 6);
		float num; // randomly generated #
		bool isValid;
		do {
			isValid = true;
			num = round(dist(this->randGen));
			if (num < Mem_Min || num > Mem_Max)
				isValid = false;
		} while (!isValid);

		int finalNum = (int)num;

		return finalNum;
	}
};

// Represents a single processor, containing a list of processes
// And properties related to processes & scheduling
class Processor
{
friend class Scheduler_SJF;
private:
	std::vector <Process> processes;
	unsigned int cpuID;
	int currentCycle; // The cycle that the processor is currently running
	int job; // The job processor is currently working on
	bool jobsCompleted; // Flag tells scheduler whether all the avaiable jobs have completed or not
	int totalWaitTime;
	int totalPenalty;
public:
	Processor()
	{
		processes.clear();
		this->currentCycle = 0;
		this->jobsCompleted = false;
		this->totalWaitTime = 0;
	}
	// Searches list of available processes and finds the shortest job available to schedule
	// Returns the index of shortest job if any available
	// If none found, returns -1
	int findShortestJob()
	{
		int arrival;
		int cycles;
		int shortestJobIndex = -1; // Default to no shortest job
		int shortestJobCycles = 0; // Keeps track of the current shotest job's cycle length
		for (int i = 0; i < this->processes.size(); i++) // Iterate process list
		{
			arrival = this->processes[i].getArrivalTime(); // Store arrival time of the process currently being examined
			cycles = this->currentCycle; // Store cycle length of process currently being examined
			if (arrival <= this->currentCycle) // process has arrived within appropriate period, test for shortest job
			{
				if (this->processes[i].getCycleLength() > 0) // Only test this process if it has cycles left to process
				{
					// If there isn't currently a shortest job found with remaining cycles, we will choose this job as the currently found shortest job
					// Otherwise, test if this new process has a lower cycle length than the currently selected shortest job
					if (shortestJobCycles == 0 || this->processes[i].getCycleLength() < shortestJobCycles) // A new shortest job has been found, so save its index (in process list) and cycle length
					{
						shortestJobIndex = i; // save index of new shortest job
						shortestJobCycles = this->processes[i].getCycleLength(); // save cycle length of new shortest job
					}
				}
			}
		}
		return shortestJobIndex;
	}
	// Simulate processing cycle
	// Progresses by one cycle if no jobs are currently running
	// Otherwise, progresses by the full cycle length of current job (effectively simulating a full run of the job)
	void simulateCycle()
	{
		int arrivalTime = 0;
		int waitTime = 0;
		int cycleLength = 0;
		job = this->findShortestJob(); // Look for the next available (shortest) job to process
		if (job != -1) // There is a job available for processing
		{
			arrivalTime = this->processes[job].getArrivalTime();
			waitTime = this->currentCycle - arrivalTime;
			cycleLength = this->processes[job].getCycleLength();
			this->processes[job].setWaitTime(waitTime); // Set the processes wait time
			this->totalWaitTime += waitTime; // Add current job's wait time to the overall wait time total
			std::cout << "cpu(" << this->cpuID << "), p" << this->processes[job].getPID() << " wait time=" << waitTime << ", job started: " << this->currentCycle << ", completed: " << (this->currentCycle + cycleLength) << std::endl;
			// The scheduler simulates in this one step the full completion of current job's total cycle time (since non-preemptive)
			this->currentCycle += (cycleLength + CONTEXT_PENALTY); // Since SJF is non-preemptive, increment cycles by process' cycle length to simulate full run of process + context switch penalty
			this->processes[job].setCycleLength(0); // Job complete - set cycle length to zero so scheduler knows job has run its course
		}
		else // jobs still exist, but none available currently so just increment by one cycle
		{
			this->currentCycle++;
		}
	}
};

// Scheduler - SJF
class Scheduler_SJF
{
private:
	float averageWaitTime;
	int totalPenalty; // context switch penalty (calculated after scheduler completion)
	int totalWaitTime; // Total wait time of the scheduling algorithm (accumulated as scheduler runs its course)
	bool multiProcessors; // Flag whether to use single process or multi processor scheduling
	// Iterates list of processes and finds the appropriate shortest job
	// In the case of a tie, preference goes to job that appears first in list
	// Returns index of shortest job in process list (pGen->processes)
	// If no available process, returns -1
	std::vector <Processor> processors;	// List of processors - each processor contains a list of its respective processes to schedule
	// Checks whether there still exist jobs with cycles left to run
	// Tells the scheduler whether it has completed its task or not
	bool validJobsExist()
	{
		bool valid = false; // default to no valid jobs
		for (int processor = 0; processor < this->processors.size(); processor++) // Search through all processors
		{
			for (int i = 0; i < this->processors[processor].processes.size(); i++) // Search process list of current processor for any valid jobs
			{
				if (this->processors[processor].processes[i].getCycleLength() > 0) // A process with a cycle length greater than 0 means there are still jobs left to complete
				{
					valid = true;
				}
			}
		}
		return valid;
	}
public:
	ProcessGenerator *pGen; // Pointer to a process generator (to generate and also store a list of generated processes to work with)
	// Constructor - initialize object & create a new instance of self-contained process generator
	//Argument 1 is a flag whether scheduler should run with single or multiple (4) processes
	Scheduler_SJF(bool multiProcessors = false)
	{
		this->processors.clear();
		this->multiProcessors = multiProcessors;
		this->pGen = new ProcessGenerator(); // initialize a new process generator object
		this->averageWaitTime = 0.0;
		this->totalWaitTime = 0;
		this->totalPenalty = 0;  // Set context switch penalty total to 0 (no jobs have run yet)
	}
	// Deconstructer - delete pointer to process generator
	~Scheduler_SJF()
	{
		delete this->pGen; // clean pointer from memory
	}
	// Runs the scheduler system
	void run(unsigned int numProcesses)
	{
		this->pGen->generate_batch(numProcesses); // Generate list of random processes (50 total)
		//this->pGen->generate_known(); numProcesses = this->pGen->processes.size();// Generate list of known processes to test with
		
		// Set up processors that will do the scheduling work
		this->processors.clear(); // Clear processors list
		Processor newCPU; // Temp object to hold a new processor (when pushed to list is added as a copy, so only one needed)
		newCPU.cpuID = 0;
		this->processors.push_back(newCPU); // Add first processor to list (copy newCPU object)
		if (this->multiProcessors) // Multi-processing enabled, add 3 more processors to list
		{
			for (int i = 1; i <= 3; i++)
			{
				newCPU.cpuID = i;
				this->processors.push_back(newCPU); // Copy temp cpu object to list
			}
		}
		int numCPUs = this->processors.size(); // save # of processors to mem
		// Calculate how many processes will go to each processor (as int value - any leftover processes, from a floating point remainder, will be distributed from first to last processor until all have been distrubuted)
		int numProcessors = this->processors.size(); // Calculate how many processes to distribute per processor
		// Distribute processes amongst the available processors
		for (int i = 0; i < numProcesses; i+=numCPUs) // Step through process list
		{
			for (int j = 0; j < numCPUs; j++) // Iterate processors and distribute current subset of processes amongst them
			{
				if ((i + j) < numProcesses) // Make sure within bounds
					this->processors[j].processes.push_back(this->pGen->processes[(i + j)]); // Copy process to processor
			}
		}

		// Execute scheduling loop
		while (this->validJobsExist()) // Loops simulates cpu cycles until all jobs are completed (0 cycles left)
		{
			for (int currentProc = 0; currentProc < numProcessors; currentProc++) // Iterate each process & simulate processing cycle(s) on each
			{
				this->processors[currentProc].simulateCycle(); // Simulate cycle on current processor
			}
		}
		// All jobs completed

		// Output analysis results
		std::cout << "Scheduler completed." << std::endl;
		std::cout << "===============================" << std::endl;
		std::cout << "# of processes=" << this->pGen->processes.size() << std::endl;
		std::cout << "# of processors=" << this->processors.size() << std::endl;
		// Aggregate all processors' total wait times to find scheduler's total wait time
		// Also, output each processor's individual total wait times
		this->totalPenalty = 0;
		for (int processor = 0; processor < this->processors.size(); processor++)
		{
			this->totalPenalty += (this->processors[processor].processes.size() - 1) * CONTEXT_PENALTY;
			this->totalWaitTime += this->processors[processor].totalWaitTime;
			std::cout << "cpu(" << processor << "), total wait time=" << this->processors[processor].totalWaitTime << std::endl;
		}
		std::cout << "total wait time=" << this->totalWaitTime << std::endl;
		this->averageWaitTime = round((float) this->totalWaitTime / (float) this->pGen->processes.size()); // Calculate average wait time
		std::cout << "avg. wait time=" << this->averageWaitTime << std::endl;

		std::cout << "total context switch penalty=" << this->totalPenalty << std::endl;
	}
};

int main(int argc, char **argv)
{
	unsigned const int NUM_PROCESSES = 50; // # of processes to generate, default to 50 (the mandated # of processes for the project)
	bool multiProcess = false; // default to single processor scheduler

	if (argc > 1) // Check for input argument
	{
		if (atoi(argv[1]) == 1) // Multi-Processor flag set to 1 (true)
			multiProcess = true;
	}

	Scheduler_SJF sjf(multiProcess); // Initialize a new SJF scheduler, either single or multi (4) processor
	sjf.run(NUM_PROCESSES);	// Begin the scheduler
	std::cout << std::endl << std::endl;

	return 0; // Bye bye folks, thanks for visiting
}